<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1252">
<TITLE>DASMx -- A microprocessor opcode disassembler</TITLE>
</HEAD>
<BODY>

<B><FONT FACE="AvantGarde,Century Gothic" SIZE=7><P>DASMx</P>
</B></FONT><I><FONT FACE="AvantGarde,Century Gothic" SIZE=5><P>Version 1.30, 6<SUP>th</SUP> October 1999</P>
</I></FONT><B><FONT FACE="AvantGarde,Century Gothic" SIZE=6><P>A microprocessor opcode disassembler</P>
</FONT><FONT FACE="AvantGarde,Century Gothic" SIZE=5><P>&copy; Copyright 1996-1999  Conquest Consultants</P>
</FONT><FONT FACE="AvantGarde,Century Gothic" SIZE=6><P><A NAME="_Toc320414400"><A NAME="_Toc329653727"><A NAME="_Toc330614476"><A NAME="_Toc346335199">Introduction</A></A></A></A></P>
</FONT><FONT FACE="Palatino,Book Antiqua"><P ALIGN="JUSTIFY">DASMx</B> is a disassembler for a range of common 8-bit microprocessors.  The following main processor families are supported:</P>

<UL TYPE="CIRCLE">
<LI>Motorola 6800 family and single chip variants (including Hitachi 630<I>X</I> devices);</LI>
<LI>Motorola 6809;</LI>
<LI>MOS Technology 6502 and Rockwell 65C0<I>X</I>;</LI>
<LI>Zilog Z80;</LI>
<LI>Sharp LR35902 (single chip Z80 variant as used in the Nintendo GameBoy);</LI>
<LI>Intel MCS-80/85<SUP>TM</SUP> family (i.e. 8080 and 8085);</LI>
<LI>Intel MCS-48<SUP>TM</SUP> family (i.e. 8048 et al);</LI>
<LI>Intel MCS-51<SUP>TM</SUP> family (i.e. 8051 et al);</LI>
<LI>Signetics 2650.</LI></UL>

<P ALIGN="JUSTIFY">The disassembler takes as input a binary code/data image file (typically a ROM image) and generates either an assembler source file or a listing file.  <B>DASMx</B> is a <I>multi-pass</I> disassembler with automatic symbol generation.  <B>DASMx</B> can optionally use a symbol file containing user-defined symbols and specifications of data areas within the source image.</P>
<B><P ALIGN="JUSTIFY">DASMx</B> includes a powerful feature called <I>code threading</I>.  Using known code entry points (e.g. reset and interrupt vectors) and by performing partial emulation of the processor, the disassembler is able to follow known code paths within a source binary image.</P>
<P ALIGN="JUSTIFY">Use of code threading, together with the multi-pass operation and symbol table management permits readable assembly code output from source images that contain large amounts of data (which tend to confuse most disassemblers).</P>
<B><P ALIGN="JUSTIFY">DASMx</B> is copyright software.  This version (1.30) may be distributed and used freely provided that all files are included in the distribution, no files are modified (including the distribution zip file) and no charge is made beyond that reasonable to cover copying (say 5 UK pounds).</P>
<I><P ALIGN="JUSTIFY">Historical note</I>: Version 1.10 of <B>DASMx</B> superseded the Motorola 680x disassembler, <B>dasm6800</B> (last released as version 1.00 on 25<SUP>th</SUP> January 1997).  The change of name reflected the wide range of processors then covered.</P>
<P ALIGN="JUSTIFY">Summarising, the key features of <B>DASMx</B> are:</P>

<UL TYPE="CIRCLE">
<LI>Disassembly of object code images for the following microprocessors:</LI><DIR>
<DIR>


<UL>
<LI>Motorola 6800, 6802 and 6808;</LI>
<LI>Motorola 6801 and 6803;</LI>
<LI>Hitachi 6301 and 6303;</LI>
<LI>Motorola 6809 and Hitachi 6309;</LI>
<LI>MOS Technology/Rockwell 6502;</LI>
<LI>Rockwell 65C00/21 and 65C59;</LI>
<LI>Rockwell 65C02, 65C102 and 65C112;</LI>
<LI>Zilog Z80;</LI>
<LI>Intel 8080 and 8085;</LI>
<LI>Sharp LR35902 (i.e. GameBoy processor);</LI>
<LI>Intel 8048;</LI>
<LI>Intel 8051;</LI>
<LI>Signetics 2650.</LI></UL>
</DIR>
</DIR>

<LI TYPE="CIRCLE">Multi-pass operation, with automatic symbol generation for jump, call and data target addresses;</LI>
<LI>Code threading (used to automatically differentiate code from data);</LI>
<LI>Control file containing user defined symbols, specifications of data areas and code entry points;</LI>
<LI>Generation of full listing or assembler output file;</LI>
<LI>Runs from the command line under Windows 95/98 or Windows&nbsp;NT/2000.</LI></UL>

</FONT><B><FONT FACE="AvantGarde,Century Gothic" SIZE=6><P>Version history</P>
</B></FONT><FONT FACE="Palatino,Book Antiqua"><P ALIGN="JUSTIFY"></P></FONT>
<TABLE BORDER CELLSPACING=2 BORDERCOLOR="#000000" CELLPADDING=7 WIDTH=576>
<TR><TD WIDTH="13%" VALIGN="TOP">
<B><I><FONT FACE="Palatino,Book Antiqua"><P ALIGN="CENTER">Version</B></I></FONT></TD>
<TD WIDTH="25%" VALIGN="TOP">
<B><I><FONT FACE="Palatino,Book Antiqua"><P ALIGN="CENTER">Date</B></I></FONT></TD>
<TD WIDTH="62%" VALIGN="TOP">
<B><I><FONT FACE="Palatino,Book Antiqua"><P>Comments</B></I></FONT></TD>
</TR>
<TR><TD WIDTH="13%" VALIGN="TOP">
<FONT FACE="Palatino,Book Antiqua"><P ALIGN="CENTER">0.90</FONT></TD>
<TD WIDTH="25%" VALIGN="TOP">
<FONT FACE="Palatino,Book Antiqua"><P ALIGN="CENTER">28<SUP>th</SUP> July 1996</FONT></TD>
<TD WIDTH="62%" VALIGN="TOP">
<FONT FACE="Palatino,Book Antiqua"><P>First public release (as <B>dasm6800</B>): with support for 6800/6802/6808 only.</FONT></TD>
</TR>
<TR><TD WIDTH="13%" VALIGN="TOP">
<FONT FACE="Palatino,Book Antiqua"><P ALIGN="CENTER">1.00</FONT></TD>
<TD WIDTH="25%" VALIGN="TOP">
<FONT FACE="Palatino,Book Antiqua"><P ALIGN="CENTER">25<SUP>th</SUP> January 1997</FONT></TD>
<TD WIDTH="62%" VALIGN="TOP">
<FONT FACE="Palatino,Book Antiqua"><P>Second release (as <B>dasm6800</B>): 6801/6803 and 6809 support added; other improvements in performance and listing output.</FONT></TD>
</TR>
<TR><TD WIDTH="13%" VALIGN="TOP">
<FONT FACE="Palatino,Book Antiqua"><P ALIGN="CENTER">1.10</FONT></TD>
<TD WIDTH="25%" VALIGN="TOP">
<FONT FACE="Palatino,Book Antiqua"><P ALIGN="CENTER">16<SUP>th</SUP> July 1997</FONT></TD>
<TD WIDTH="62%" VALIGN="TOP">
<FONT FACE="Palatino,Book Antiqua"><P>Third release (now renamed <B>DASMx</B>): 6502, Z80 and 8048 processor support added; minor improvements and bug fixes.</FONT></TD>
</TR>
<TR><TD WIDTH="13%" VALIGN="TOP">
<FONT FACE="Palatino,Book Antiqua"><P ALIGN="CENTER">1.20</FONT></TD>
<TD WIDTH="25%" VALIGN="TOP">
<FONT FACE="Palatino,Book Antiqua"><P ALIGN="CENTER">2<SUP>nd</SUP> April 1998</FONT></TD>
<TD WIDTH="62%" VALIGN="TOP">
<FONT FACE="Palatino,Book Antiqua"><P>8080, 8085 and 2650 processor support added; improvements and bug fixes.</FONT></TD>
</TR>
<TR><TD WIDTH="13%" VALIGN="TOP">
<FONT FACE="Palatino,Book Antiqua"><P ALIGN="CENTER">1.30</FONT></TD>
<TD WIDTH="25%" VALIGN="TOP">
<FONT FACE="Palatino,Book Antiqua"><P ALIGN="CENTER">6<SUP>th</SUP> October 1999</FONT></TD>
<TD WIDTH="62%" VALIGN="TOP">
<FONT FACE="Palatino,Book Antiqua"><P>6301, 6303, 65C00/21, 65C29, 65C02, 65C102, 65C112, 8051 and LR35902 processor support added; wide listing format showing execution cycles; checksum and CRC-32 calculation; number format improvements; new symbol file directives; other improvements and bug fixes.</FONT></TD>
</TR>
</TABLE>

<FONT FACE="Palatino,Book Antiqua"><P ALIGN="JUSTIFY">&nbsp;</P>
<P ALIGN="JUSTIFY">The changes from version 1.20 are:</P>

<UL TYPE="CIRCLE">
<LI>Disassembly of Hitachi 6301 and 6303 added;</LI>
<LI>Disassembly of Rockwell 65C00/21, 65C29, 65C02, 65C102 and 65C112 added;</LI>
<LI>Disassembly of Intel 8051 added;</LI>
<LI>Disassembly of Sharp LR35902 (GameBoy processor) added;</LI>
<LI>Corrected documentation concerning Hitachi 6309 (which has, in fact, an identical instruction set to the 6809);</LI>
<LI>Labelling and threading improvements for 8080, 8085 and Z80 disassembly (affects RST and indirect addressing instructions);</LI>
<LI>Correction to instruction format for 2650 lodz/eorz/andz/…;</LI>
<LI>New wide listing format showing execution cycles for each instruction;</LI>
<LI>File size, checksum and CCITT CRC-32 calculated and shown in listing header;</LI>
<LI>Auto number format determined by processor type (which can be overriden by a directive in the symbol file);</LI>
<LI>User messages can now be specified and generated from the symbol file;</LI>
<LI>Symbol file includes (which may be nested) now permitted.</LI></UL>

<P ALIGN="JUSTIFY">The changes between versions 1.10 and 1.20 were:</P>

<UL TYPE="CIRCLE">
<LI>Disassembly of Intel 8080 and 8085 added (in addition to existing support for 8080 provided by Z80 disassembly);</LI>
<LI>Disassembly of Signetics 2650 added;</LI>
<LI>New symbol file command to skip areas of source image;</LI>
<LI>Origin can now be specified in symbol file;</LI>
<LI>New command line option to specify a single code entry point for threading;</LI>
<LI>New command line option to list all processors supported;</LI>
<LI>Fix to incorrect disassembly of 6801/6803 subd instruction (opcode 0x93);</LI>
<LI>Bug fixes and other minor changes.</LI></UL>

<P ALIGN="JUSTIFY">The changes between versions 1.00 and 1.10 were:</P>

<UL TYPE="CIRCLE">
<LI>All references to "dasm6800" replaced by "DASMx";</LI>
<LI>Disassembly of 6502 added;</LI>
<LI>Disassembly of Z80 added;</LI>
<LI>Disassembly of 8048 added;</LI>
<LI>Minor bug fix for code threading of 6801/6803 direct branch instructions;</LI>
<LI>Minor changes to listing output;</LI>
<LI>Bug fixes and other minor improvements.</LI></UL>

<P ALIGN="JUSTIFY">The changes between versions 0.90 and 1.00 were:</P>

<UL TYPE="CIRCLE">
<LI>Disassembly of 6801/6803 added;</LI>
<LI>Disassembly of 6809 added;</LI>
<LI>Define byte pseudo-op now generates full listing;</LI>
<LI>Two new commands supported in symbol file: </FONT><FONT FACE="Courier">cpu</FONT><FONT FACE="Palatino,Book Antiqua"> (to select processor type) and </FONT><FONT FACE="Courier">addrtab</FONT><FONT FACE="Palatino,Book Antiqua"> (to define a table of addresses, each of which points to data);</LI>
<LI>New command line switch to select processor type;</LI>
<LI>Performance improvement to pass 1;</LI>
<LI>Minor changes to listing output;</LI>
<LI>Bug fixes and other minor improvements.</LI></UL>

</FONT><B><FONT FACE="AvantGarde,Century Gothic" SIZE=6><P>Copyright</P>
</FONT><FONT FACE="Palatino,Book Antiqua"><P ALIGN="JUSTIFY">DASMx</B> and all associated documentation are copyright Conquest Consultants.</P>
</FONT><B><FONT FACE="AvantGarde,Century Gothic" SIZE=6><P>Disclaimer</P>
</FONT><FONT FACE="Palatino,Book Antiqua"><P ALIGN="JUSTIFY">DASMx</B> comes without any express or implied warranty.  You use this software at your own risk.  Conquest Consultants have no obligation to support or upgrade this software.  Conquest Consultants cannot be held responsible for any act of copyright infringement or other violation of applicable law that results from use of this disassembler software.</P>
</FONT><B><FONT FACE="AvantGarde,Century Gothic" SIZE=6><P>Distribution</P>
</FONT><FONT FACE="Palatino,Book Antiqua"><P ALIGN="JUSTIFY">DASMx</B> is copyright software.  This version (1.30) may be distributed and used freely provided that all files are included in the distribution, no files (including the distribution zip file) are modified and no charge is made beyond that reasonable to cover copying (say 5 UK pounds).  Conquest Consultants reserve the right to alter the free distribution and use terms for any future versions or derivatives of <B>DASMx</B> that may be produced.</P>
<B><P ALIGN="JUSTIFY">DASMx</B> version 1.30 is distributed as file <B>dasmx130.zip</B> in the /msdos/disasm section of the Simtel and Simtel.net archives.  Provided that the above distribution terms are adhered to, this file may be freely copied to and mirrored at other ftp and WWW sites.</P>
</FONT><B><FONT FACE="AvantGarde,Century Gothic" SIZE=6><P>Operation</P>
</B></FONT><FONT FACE="Palatino,Book Antiqua"><P ALIGN="JUSTIFY">Before describing the operation of <B>DASMx</B> in detail, here is an overview of how the disassembler will be typically used in practice.</P>
<P ALIGN="JUSTIFY">First, you must obtain a file containing a binary image of the code/data that you wish to disassemble.  Typically, this will be from one or more ROMs or EPROMs that have been read using a PROM programmer.  Some PROM programmers output data in a form of ASCII hexadecimal format (Intel and Motorola are two common formats).  If that is the case, then you must use a conversion utility to generate a raw binary image.  A good check that you have a correct binary image of a complete ROM is that the file length (shown by a DIR command) will be a power of two and will correspond to the length of the ROM.  For example, the file size of a complete image of a 27256 EPROM will be 32,768 bytes.</P>
<P ALIGN="JUSTIFY">Assuming at this stage that you do not know which areas of the binary image are code and which are data, it is sensible to use the code threading feature.  For code threading to work, you must provide at least one code entry point.  This requires </FONT><FONT FACE="Courier">code</FONT><FONT FACE="Palatino,Book Antiqua">, </FONT><FONT FACE="Courier">vector</FONT><FONT FACE="Palatino,Book Antiqua"> or </FONT><FONT FACE="Courier">vectab</FONT><FONT FACE="Palatino,Book Antiqua"> entries in a symbol file.  For example, if you are disassembling a ROM image from the uppermost region of the 6800 microprocessor address space, then four </FONT><FONT FACE="Courier">vector</FONT><FONT FACE="Palatino,Book Antiqua"> entries for the standard interrupt and reset vectors will be all that is initially required to provide the necessary entry points.  You can also improve the readability of the disassembled output by defining symbols for all known hardware addresses (e.g. PIA registers and other ports).</P>
<P ALIGN="JUSTIFY">Try modifying one of the supplied example symbol files to suit your application.  It is important that the correct processor type is specified using a </FONT><FONT FACE="Courier">cpu</FONT><FONT FACE="Palatino,Book Antiqua"> directive in the symbol file (or by command line switch).  The disassembler will not make much sense of Z80 code if it thinks that the processor is a 6502!</P>
<P ALIGN="JUSTIFY">Run the disassembler with code threading.  This will identify all known areas of code.  Data and unknown areas will be listed as byte data rather than disassembled into instruction mnemonics.  Due to limitations of the code threading process (see below) not all code areas may be identified.  Any additional code entry points or address vector tables can be added to the symbol file.  Similarly, areas of byte, word or string data that can be identified from examination of the disassembly listing can also be recorded in the symbol file.</P>
<P ALIGN="JUSTIFY">Using a repeated "disassemble, inspect listing, update symbol file" cycle a comprehensive disassembly of an image can be built up quite quickly.</P>
<P ALIGN="JUSTIFY">Finally, if you are satisfied that you have identified all main data areas, try disassembling without code threading.  This will help pick up areas of code that may have been missed by the code threading and subsequent manual investigation process.</P>
</FONT><B><FONT FACE="AvantGarde,Century Gothic" SIZE=5><P>Platform</P>
</FONT><FONT FACE="Palatino,Book Antiqua"><P ALIGN="JUSTIFY">DASMx</B> is a Win32 console application.  This means that it is a 32-bit application that requires Windows 95/98/Millenium or Windows NT/2000 to run.  Typically, you will run the disassembler from a DOS box command line.</P>
</FONT><B><FONT FACE="AvantGarde,Century Gothic" SIZE=5><P>Command line options</P>
</FONT><FONT FACE="Palatino,Book Antiqua"><P ALIGN="JUSTIFY">DASMx</B> has the following command line options:</P></FONT>
<TABLE CELLSPACING=0 BORDER=0 CELLPADDING=7 WIDTH=602>
<TR><TD WIDTH="18%" VALIGN="TOP">
<B><FONT FACE="Palatino,Book Antiqua"><P ALIGN="JUSTIFY">-a</B></FONT></TD>
<TD WIDTH="82%" VALIGN="TOP">
<FONT FACE="Palatino,Book Antiqua"><P ALIGN="JUSTIFY">generate assembler output (default is to generate a full listing file);</FONT></TD>
</TR>
<TR><TD WIDTH="18%" VALIGN="TOP">
<B><FONT FACE="Palatino,Book Antiqua"><P ALIGN="JUSTIFY">-c</B><I>TYPE</I></FONT></TD>
<TD WIDTH="82%" VALIGN="TOP">
<FONT FACE="Palatino,Book Antiqua"><P ALIGN="JUSTIFY">set the CPU processor type – overrides any </FONT><FONT FACE="Courier">cpu</FONT><FONT FACE="Palatino,Book Antiqua"> statement in the symbol file, where <I>TYPE</I> is one of the types reported by the <B>-l</B> option (6800, 6809, 6502, Z80 etc.) (default is 6800);</FONT></TD>
</TR>
<TR><TD WIDTH="18%" VALIGN="TOP">
<B><FONT FACE="Palatino,Book Antiqua"><P ALIGN="JUSTIFY">-e</B><I>NNNN</I></FONT></TD>
<TD WIDTH="82%" VALIGN="TOP">
<FONT FACE="Palatino,Book Antiqua"><P ALIGN="JUSTIFY">specify a code entry point <I>NNNN</I> for threading;</FONT></TD>
</TR>
<TR><TD WIDTH="18%" VALIGN="TOP">
<B><FONT FACE="Palatino,Book Antiqua"><P ALIGN="JUSTIFY">-l</B></FONT></TD>
<TD WIDTH="82%" VALIGN="TOP">
<FONT FACE="Palatino,Book Antiqua"><P ALIGN="JUSTIFY">list all processors supported and exit;</FONT></TD>
</TR>
<TR><TD WIDTH="18%" VALIGN="TOP">
<B><FONT FACE="Palatino,Book Antiqua"><P ALIGN="JUSTIFY">-o</B><I>NNNN</I></FONT></TD>
<TD WIDTH="82%" VALIGN="TOP">
<FONT FACE="Palatino,Book Antiqua"><P ALIGN="JUSTIFY">set the origin, or start address to <I>NNNN</I> (default is top of address space less the length of the source image);</FONT></TD>
</TR>
<TR><TD WIDTH="18%" VALIGN="TOP">
<B><FONT FACE="Palatino,Book Antiqua"><P ALIGN="JUSTIFY">-t</B></FONT></TD>
<TD WIDTH="82%" VALIGN="TOP">
<FONT FACE="Palatino,Book Antiqua"><P ALIGN="JUSTIFY">perform code threading (requires at least one code entry point to be specified);</FONT></TD>
</TR>
<TR><TD WIDTH="18%" VALIGN="TOP">
<B><FONT FACE="Palatino,Book Antiqua"><P ALIGN="JUSTIFY">-v</B></FONT></TD>
<TD WIDTH="82%" VALIGN="TOP">
<FONT FACE="Palatino,Book Antiqua"><P ALIGN="JUSTIFY">display version information and exit;</FONT></TD>
</TR>
<TR><TD WIDTH="18%" VALIGN="TOP">
<B><FONT FACE="Palatino,Book Antiqua"><P ALIGN="JUSTIFY">-w</B></FONT></TD>
<TD WIDTH="82%" VALIGN="TOP">
<FONT FACE="Palatino,Book Antiqua"><P ALIGN="JUSTIFY">wide listing format (shows instruction cycles and up to 8 data bytes per line).</FONT></TD>
</TR>
</TABLE>

<FONT FACE="Palatino,Book Antiqua"><P ALIGN="JUSTIFY">When specifying addresses, the number <I>NNNN</I> should be specified using C language conventions (i.e. default is decimal, prefix with 0x for hex, prefix with 0 for octal).</P>
</FONT><B><FONT FACE="AvantGarde,Century Gothic" SIZE=5><P>Input files</P>
</B></FONT><FONT FACE="Palatino,Book Antiqua"><P ALIGN="JUSTIFY">The primary input file is a binary image of the code/data to be disassembled.  This must be code for one of the supported microprocessors (or other manufacturer equivalent).  <B>DASMx</B> will produce meaningless output for any other type of processor.</P>
<B><P ALIGN="JUSTIFY">DASMx</B> assumes a file extension of ".bin" unless otherwise specified for the binary image file.</P>
<B><P ALIGN="JUSTIFY">DASMx</B> looks for a symbol file of the same base name as the source binary file, but with a ".sym" file extension.  If a symbol file is found, it will be used.  Provision of a symbol file is optional, except where code threading is used (where a symbol file must be used to define at least one code entry point).</P>
</FONT><B><FONT FACE="AvantGarde,Century Gothic" SIZE=4><P>Symbol file syntax</P>
</B></FONT><FONT FACE="Palatino,Book Antiqua"><P ALIGN="JUSTIFY">The symbol file is a plain text file that may be created/modified with any text editor.  The file contains lines that fall into one of three categories:</P>

<UL TYPE="CIRCLE">
<LI>comment lines;</LI>
<LI>command lines;</LI>
<LI>blank lines.</LI></UL>

<P ALIGN="JUSTIFY">Comment lines are denoted by '</FONT><FONT FACE="Courier">;</FONT><FONT FACE="Palatino,Book Antiqua">' as the first non-whitespace character on the line.  Command lines start with one of the specified keywords.  Parameters follow the command keyword, separated by spaces or tabs.  A comment may be added to the end of a command, preceded by the '</FONT><FONT FACE="Courier">;</FONT><FONT FACE="Palatino,Book Antiqua">' character.  Blank lines are ignored.</P>
<P ALIGN="JUSTIFY">Number value parameters may be given in decimal (the default), octal or hex using standard C language conventions (e.g. 0x prefix for hex).</P>
<P ALIGN="JUSTIFY">The symbol file command syntax contains an </FONT><FONT FACE="Courier">include</FONT><FONT FACE="Palatino,Book Antiqua"> directive which allows one symbol file to be included within another.  Included files may be nested to any practical depth.  A particular use of this feature is to have a symbol file containing a generic set of defintions for a processor or item of hardware.  This can then be included within a symbol file with additional definitions for a specific software image that runs on that processor/hardware.  The pair of example files, <B>gameboy.sym</B> and <B>tetris.sym</B>, shows this in action with generic GameBoy definitions in one file and specific defintions for a tetris game cartidge in the other.</P>
<P ALIGN="JUSTIFY">Valid command keywords and their meaning are summarised in the table below.</P>
<P ALIGN="JUSTIFY"></P></FONT>
<TABLE BORDER CELLSPACING=2 BORDERCOLOR="#000000" CELLPADDING=7 WIDTH=602>
<TR><TD WIDTH="16%" VALIGN="TOP">
<B><I><FONT FACE="Palatino,Book Antiqua"><P ALIGN="JUSTIFY">Command</B></I></FONT></TD>
<TD WIDTH="84%" VALIGN="TOP">
<B><I><FONT FACE="Palatino,Book Antiqua"><P>Function/syntax</B></I></FONT></TD>
</TR>
<TR><TD WIDTH="16%" VALIGN="TOP">
<B><FONT FACE="Palatino,Book Antiqua"><P ALIGN="JUSTIFY">cpu</B></FONT></TD>
<TD WIDTH="84%" VALIGN="TOP">
<FONT FACE="Palatino,Book Antiqua"><P>Specify the processor type.<BR>
<I>Syntax</I>: </FONT><FONT FACE="Courier">cpu 2650 | 6502 | 65C00 | 65C59 | 65C02 | 65C102 | 65C112 | 6301 | 6303 | 6800 | 6801 | 6802 | 6803 | 6808 | 6809 | 8048 | 8051 | 8080 | 8085 | Z80 | LR35902</FONT></TD>
</TR>
<TR><TD WIDTH="16%" VALIGN="TOP">
<B><FONT FACE="Palatino,Book Antiqua"><P ALIGN="JUSTIFY">numformat</B></FONT></TD>
<TD WIDTH="84%" VALIGN="TOP">
<FONT FACE="Palatino,Book Antiqua"><P>Specify number format (overriding default for processor) as Intel, Motorola, Signetics, C language hex (i.e. 0x prefix) or decimal.<BR>
<I>Syntax</I>: </FONT><FONT FACE="Courier">numformat I | M | S | C | D</FONT></TD>
</TR>
<TR><TD WIDTH="16%" VALIGN="TOP">
<B><FONT FACE="Palatino,Book Antiqua"><P ALIGN="JUSTIFY">include</B></FONT></TD>
<TD WIDTH="84%" VALIGN="TOP">
<FONT FACE="Palatino,Book Antiqua"><P>Include a file containing additional symbol commands.  Include filess may be nested.<BR>
<I>Syntax</I>: </FONT><FONT FACE="Courier">include <I>&lt;filename&gt;</I></FONT></TD>
</TR>
<TR><TD WIDTH="16%" VALIGN="TOP">
<B><FONT FACE="Palatino,Book Antiqua"><P ALIGN="JUSTIFY">message</B></FONT></TD>
<TD WIDTH="84%" VALIGN="TOP">
<FONT FACE="Palatino,Book Antiqua"><P>Generate a message to the console during disassembly.<BR>
<I>Syntax</I>: </FONT><FONT FACE="Courier">message "<I>&lt;message string&gt;</I>"</FONT><FONT FACE="Palatino,Book Antiqua"><BR>
<I>or</I>: </FONT><FONT FACE="Courier">message <I>&lt;word1&gt;</I> [<I>&lt;word2&gt; &lt;word3&gt;</I> ...]</FONT></TD>
</TR>
<TR><TD WIDTH="16%" VALIGN="TOP">
<B><FONT FACE="Palatino,Book Antiqua"><P ALIGN="JUSTIFY">org</B></FONT></TD>
<TD WIDTH="84%" VALIGN="TOP">
<FONT FACE="Palatino,Book Antiqua"><P>Define the start address for the first byte of the code/data image.  Note that only one org statement should be present in a symbol file.<BR>
<I>Syntax</I>: </FONT><FONT FACE="Courier">org <I>&lt;address&gt;</I></FONT></TD>
</TR>
<TR><TD WIDTH="16%" VALIGN="TOP">
<B><FONT FACE="Palatino,Book Antiqua"><P ALIGN="JUSTIFY">symbol</B></FONT></TD>
<TD WIDTH="84%" VALIGN="TOP">
<FONT FACE="Palatino,Book Antiqua"><P>Define a symbol corresponding to a value (usually an address).<BR>
<I>Syntax</I>: </FONT><FONT FACE="Courier">symbol <I>&lt;value&gt;</I> <I>&lt;name&gt;</I></FONT></TD>
</TR>
<TR><TD WIDTH="16%" VALIGN="TOP">
<B><FONT FACE="Palatino,Book Antiqua"><P ALIGN="JUSTIFY">vector</B></FONT></TD>
<TD WIDTH="84%" VALIGN="TOP">
<FONT FACE="Palatino,Book Antiqua"><P>Define a location that contains a word pointing to a code entry (for example, the reset entry point).<BR>
<I>Syntax</I>: </FONT><FONT FACE="Courier">vector <I>&lt;address&gt;</I> <I>&lt;vector name&gt;</I> [<I>&lt;destination name&gt;</I>]</FONT></TD>
</TR>
<TR><TD WIDTH="16%" VALIGN="TOP">
<B><FONT FACE="Palatino,Book Antiqua"><P ALIGN="JUSTIFY">vectab</B></FONT></TD>
<TD WIDTH="84%" VALIGN="TOP">
<FONT FACE="Palatino,Book Antiqua"><P>Define a table of vectors (i.e. a jump table) of length <I>&lt;count&gt;</I>.  Each vector will be used as a code entry point if threading is used.<BR>
<I>Syntax</I>: </FONT><FONT FACE="Courier">vectab <I>&lt;address&gt;</I> <I>&lt;name&gt;</I> [<I>&lt;count&gt;</I>]</FONT></TD>
</TR>
<TR><TD WIDTH="16%" VALIGN="TOP">
<B><FONT FACE="Palatino,Book Antiqua"><P ALIGN="JUSTIFY">code</B></FONT></TD>
<TD WIDTH="84%" VALIGN="TOP">
<FONT FACE="Palatino,Book Antiqua"><P>Define a code entry point (for code threading).<BR>
<I>Syntax</I>: </FONT><FONT FACE="Courier">code <I>&lt;address&gt;</I> [<I>&lt;name&gt;</I>]</FONT></TD>
</TR>
<TR><TD WIDTH="16%" VALIGN="TOP">
<B><FONT FACE="Palatino,Book Antiqua"><P ALIGN="JUSTIFY">byte</B></FONT></TD>
<TD WIDTH="84%" VALIGN="TOP">
<FONT FACE="Palatino,Book Antiqua"><P>Define a single data byte, or <I>&lt;count&gt;</I> length array of bytes.<BR>
<I>Syntax</I>: </FONT><FONT FACE="Courier">byte <I>&lt;address&gt;</I> <I>&lt;name&gt;</I> [<I>&lt;count&gt;</I>]</FONT></TD>
</TR>
<TR><TD WIDTH="16%" VALIGN="TOP">
<B><FONT FACE="Palatino,Book Antiqua"><P ALIGN="JUSTIFY">word</B></FONT></TD>
<TD WIDTH="84%" VALIGN="TOP">
<FONT FACE="Palatino,Book Antiqua"><P>Define a single data word, or <I>&lt;count&gt;</I> length array of words.<BR>
<I>Syntax</I>: </FONT><FONT FACE="Courier">word <I>&lt;address&gt;</I> <I>&lt;name&gt;</I> [<I>&lt;count&gt;</I>]</FONT></TD>
</TR>
<TR><TD WIDTH="16%" VALIGN="TOP">
<B><FONT FACE="Palatino,Book Antiqua"><P ALIGN="JUSTIFY">addrtab</B></FONT></TD>
<TD WIDTH="84%" VALIGN="TOP">
<FONT FACE="Palatino,Book Antiqua"><P>Define a table of addresses, which point to data, of length <I>&lt;count&gt;</I>.<BR>
<I>Syntax</I>: </FONT><FONT FACE="Courier">addrtab <I>&lt;address&gt;</I> <I>&lt;name&gt;</I> [<I>&lt;count&gt;</I>]</FONT></TD>
</TR>
<TR><TD WIDTH="16%" VALIGN="TOP">
<B><FONT FACE="Palatino,Book Antiqua"><P ALIGN="JUSTIFY">string</B></FONT></TD>
<TD WIDTH="84%" VALIGN="TOP">
<FONT FACE="Palatino,Book Antiqua"><P>Define a single data character, or <I>&lt;count&gt;</I> length string of chars.<BR>
<I>Syntax</I>: </FONT><FONT FACE="Courier">string <I>&lt;address&gt;</I> <I>&lt;name&gt;</I> [<I>&lt;count&gt;</I>]</FONT></TD>
</TR>
<TR><TD WIDTH="16%" VALIGN="TOP">
<B><FONT FACE="Palatino,Book Antiqua"><P ALIGN="JUSTIFY">skip</B></FONT></TD>
<TD WIDTH="84%" VALIGN="TOP">
<FONT FACE="Palatino,Book Antiqua"><P>Skip (i.e. omit from disassembly and listing) <I>&lt;count&gt;</I> length data bytes.<BR>
<I>Syntax</I>: </FONT><FONT FACE="Courier">skip <I>&lt;address&gt;</I> <I>&lt;count&gt;</I></FONT></TD>
</TR>
</TABLE>

<B><FONT FACE="AvantGarde,Century Gothic" SIZE=5><P>Output files</P>
</B></FONT><FONT FACE="Palatino,Book Antiqua"><P ALIGN="JUSTIFY">By default, <B>DASMx</B> generates a disassembly listing file.  This is similar to the full listing file generated by most assemblers.  Optionally, <B>DASMx</B> can be made to produce an assembly file instead.  This could then be used as a source file to an assembler of your choice (with certain provisos concerning pseudo-ops and number formats noted later).</P>
<P ALIGN="JUSTIFY">As an aid to readability, <B>DASMx</B> inserts a comment line after all breaks in a sequence of instructions (e.g. after an unconditional branch or jump, or a return from subroutine).  Comment lines are also inserted between code and data areas.  This use of comment lines breaks the output listing into identifiable sections and aids manual inspection of the resultant disassembly listing.</P>
<P ALIGN="JUSTIFY">Note that output files tend to be large.  For example, a 32&nbsp;Kbyte ROM image will generate a listing file of around half a megabyte in length.</P>
<P ALIGN="JUSTIFY">The output file is named based upon the name of the source image file, but with a file extension of ".lst" for the list file or ".asm" for the assembly output file.</P>
</FONT><B><FONT FACE="AvantGarde,Century Gothic" SIZE=4><P>Listing file</P>
</B></FONT><FONT FACE="Palatino,Book Antiqua"><P ALIGN="JUSTIFY">The list file format is largely self-explanatory.  Program counter and code/data byte values are given in hex.  Code/data is also shown as ASCII characters (where printable) as an aid to identifying strings within the binary image.  If the wide listing format is selected then instruction cycle counts are also given for every instruction.</P>
<P ALIGN="JUSTIFY">Instruction cycles are shown within [square braces].  If an instruction takes a variable number of cycles to execute (e.g. a conditional branch on many processors) then two values are shown: the minimum and the maximum.</P>
</FONT><B><FONT FACE="AvantGarde,Century Gothic" SIZE=5><P>Code threading</P>
</B></FONT><FONT FACE="Palatino,Book Antiqua"><P ALIGN="JUSTIFY">Code threading is a very powerful feature that will automatically identify known areas of code.  It can prove particularly useful in the early stages of disassembly of an image that contains large areas of data.  Such data areas would otherwise be disassembled incorrectly as code and would add many erroneous symbols to the symbol table.</P>
<P ALIGN="JUSTIFY">Code threading works by performing a partial emulation of the processor; executing instructions starting from one or more known entry points.  Code threading follows calls to subroutines and conditional and unconditional branches.  In certain cases, the code threading may fail to follow certain code paths (i.e. leaving valid code still defined as data).  The following are examples of where the code threader will fail to follow a correct execution path:</P>

<UL TYPE="CIRCLE">
<LI>pushing an address onto the stack and then, later, performing a return from subroutine instruction (i.e. as a method of performing a jump);</LI>
<LI>performing an indexed branch instruction (e.g. using addresses taken from a vector table);</LI>
<LI>use of undocumented instruction opcodes – since threads are abandoned when an invalid opcode is detected;</LI>
<LI>self-modifying code.</LI></UL>

<P ALIGN="JUSTIFY">Indexed branch instructions are highlighted in the output listing by automatically generated comments.  These are an indication that you need to manually identify what the contents of the index register will be prior to the branch (often obvious – look for a preceding load index register instruction.)  Then, you can add a </FONT><FONT FACE="Courier">code</FONT><FONT FACE="Palatino,Book Antiqua"> or a </FONT><FONT FACE="Courier">vectab</FONT><FONT FACE="Palatino,Book Antiqua"> entry to the symbol file and repeat the disassembly.</P>
<P ALIGN="JUSTIFY">In rare cases, code threading may incorrectly identify data as code:</P>

<UL TYPE="CIRCLE">
<LI>A call to a subroutine that never returns (e.g. the subroutine discards the return address); the other side of the call containing data rather than code.</LI>
<LI>A conditional branch that is always, or never, executed (and the other side of the branch contains data rather than code).</LI></UL>

<P ALIGN="JUSTIFY">Normally this latter scenario is pretty unlikely and requires a particularly perverse programmer of the original code.  However, it is a technique that may be encountered on those processors which had a "better" (i.e. fewer cycles and/or fewer bytes) conditional jump than unconditional jump.  So, in general, code threading will identify guaranteed known areas of code that may be a subset of the overall actual code.  Most of the above problem areas can be dealt with by manual inspection of the disassembly listing and subsequent additions to the symbol file.</P>
<P ALIGN="JUSTIFY">A thread of execution will be abandoned for one of two reasons.  If a branch or subroutine call is made outside the address range corresponding to the source image then that thread is not followed.  Also, if an invalid instruction is detected then the thread terminates immediately.  This will produce a command line error message identifying the address where the problem occurred.  Normally this represents an error condition that can be corrected by the person operating the disassembler:</P>

<UL TYPE="CIRCLE">
<LI>the processor type is incorrectly specified;</LI>
<LI>the source binary image is not real code;</LI>
<LI>an incorrect code entry point has been supplied;</LI>
<LI>so called "undocumented" instructions have been used.</LI></UL>

<P ALIGN="JUSTIFY">In rare cases, the original programmer may have done something that causes the code threader to incorrectly identify data as code.  These cases may also result in invalid instruction messages.</P>
</FONT><B><FONT FACE="AvantGarde,Century Gothic" SIZE=5><P>Microprocessor specifics</P>
</B></FONT><FONT FACE="Palatino,Book Antiqua"><P ALIGN="JUSTIFY">The following sub-sections detail items of note relating to disassembly for the specific microprocessors (and their variants) supported by <B>DASMx</B>.</P>
</FONT><B><FONT FACE="AvantGarde,Century Gothic" SIZE=4><P>Motorola 6800, 6802 and 6808</P>
</B></FONT><FONT FACE="Palatino,Book Antiqua"><P ALIGN="JUSTIFY">The Motorola 6800, 6802 and 6808 share an identical instruction set.</P>
<P ALIGN="JUSTIFY">Assembler mnemonics follow the Motorola standard definitions (see reference [1]).  Note that there are two common styles for instructions involving the A and B registers:</P>

<UL TYPE="CIRCLE">
<LI>the A or B register name is separated by whitespace from the base instruction (e.g. <B>lda&nbsp;b&nbsp;value</B>);</LI>
<LI>the A or B register name is used as a suffix to the instruction mnemonic (e.g. <B>ldab&nbsp;value</B>).</LI></UL>

<B><P ALIGN="JUSTIFY">DASMx</B> uses the latter style.  This point also applies to the 6801/6803 and 6809 mnemonics generated by the disassembler.</P>
</FONT><B><FONT FACE="AvantGarde,Century Gothic" SIZE=4><P>Motorola 6801 and 6803</P>
</B></FONT><FONT FACE="Palatino,Book Antiqua"><P ALIGN="JUSTIFY">The Motorola 6801 and 6803 share an identical instruction set that is an object code compatible superset of that of the base 6800.  These processors contain on-chip timer and I/O plus an expanded interrupt vector area over that of the 6800.  Definitions for these in a symbol file will be useful for disassembly of any 6801/6803 code.  See the supplied 6803 symbol file, <B>ebcgame.sym</B>, for an example that could be used as a template for other 6801/6803 disassembly.</P>
</FONT><B><FONT FACE="AvantGarde,Century Gothic" SIZE=4><P>Hitach 6301 and 6303</P>
</B></FONT><FONT FACE="Palatino,Book Antiqua"><P ALIGN="JUSTIFY">The Hitachi 6301 and 6303 are enhanced versions of the Motorola 6801/6803 with an enhanced object code compatible instruction set.  Differences include a few additional instructions and pipelining that improves some instruction times.</P>
</FONT><B><FONT FACE="AvantGarde,Century Gothic" SIZE=4><P>Motorola 6809 and Hitachi 6309</P>
</B></FONT><FONT FACE="Palatino,Book Antiqua"><P ALIGN="JUSTIFY">The Motorola 6809 has an instruction set that is compatible with that of the 6800<I> at the assembler level</I> (i.e. it is <I>not</I> binary compatible, but every 6800 instruction mnemonic is present in the 6809 instruction set).  The 6809 also has many additional instructions that are not present in the 6800.</P>
<P ALIGN="JUSTIFY">The Hitach 6309 is a CMOS version of the 6809 (which is fabricated using NMOS technology) that shares an identical instruction set.  Consequently, setting the processor type to 6809 may correctly disassemble 6309 code.</P>
</FONT><B><FONT FACE="AvantGarde,Century Gothic" SIZE=4><P>MOS Technology/Rockwell 6502</P>
</B></FONT><FONT FACE="Palatino,Book Antiqua"><P ALIGN="JUSTIFY">The MOS Technology/Rockwell 6502 has a similar instruction set to that of the 6800 (but totally opcode incompatible).</P>
<P ALIGN="JUSTIFY">A number of 6502 variants, with expanded instruction sets and addressing capabilities have appeared over the years.  <B>DASMx</B> copes with some, but not all, of these variants (see next sections).  If you know that a processor is based on the 6502 architecture, but are unsure of the variant then try disassembling with the CPU type set to 6502, 65C02 and 65C00.  Inspect the results and select whichever gives the most intelligent disassembly.  [Tip: try this with code threading and select the processor that gives least threading errors.]</P>
</FONT><B><FONT FACE="AvantGarde,Century Gothic" SIZE=4><P>Rockwell 65C00/21 and 65C29</P>
</B></FONT><FONT FACE="Palatino,Book Antiqua"><P ALIGN="JUSTIFY">The Rockwell 65C00/21 and 65C29 each contain two enhanced CMOS 6502 CPU cores plus on-chip masked ROM, RAM, two timers and general purpose I/O.  Instruction set differences over the basic NMOS 6502 include new instructions for unsigned multiply, memory bit set and reset, branch on bit set/reset, unconditional branch and push/pop for the index registers.  With the exception of the multiply instruction, these new instructions are a subset of the additional instructions in the 65C02.</P>
<P ALIGN="JUSTIFY">Note that the CPU type for the 65C00/21 should be specified as </FONT><FONT FACE="Courier">65C00</FONT><FONT FACE="Palatino,Book Antiqua"> (i.e. without the trailing "/21").</P>
</FONT><B><FONT FACE="AvantGarde,Century Gothic" SIZE=4><P>Rockwell 65C02, 65C102 and 65C112</P>
</B></FONT><FONT FACE="Palatino,Book Antiqua"><P ALIGN="JUSTIFY">The Rockwell 65C02 is an improved version of, and object code compatible with, the original NMOS 6502 with twelve new basic instructions (giving 59 new opcodes with variants).  The 65C02 is pin compatible with the original 6502.  The 65C102 is similar, but with minor pinout differences to provide for multi-processor bus operation.  The 65C112 has no internal clock oscillator and is designed as a slave processor to the 65C102.  The extra instructions include all of the additions found in the 65C00/21 and 65C29 dual processors – with the exception of the multiply instruction found in those devices.</P>
</FONT><B><FONT FACE="AvantGarde,Century Gothic" SIZE=4><P>Zilog Z80</P>
</B></FONT><FONT FACE="Palatino,Book Antiqua"><P ALIGN="JUSTIFY">The Zilog Z80 (also made by Mostek, Sharp, NEC and other second sources) has an instruction set that is binary compatible with that of the Intel 8080, but with many additional instructions.  Although each 8080 instruction has an identical Z80 instruction, Zilog chose to use a different mnemonic style for almost every instruction.  Consequently, Z80 assembler (even if restricted to the 8080 subset) appears quite different even though the resulting binary image is identical.</P>
<P ALIGN="JUSTIFY">The Z80 has a great many (so called) undocumented instructions that (sometimes) perform useful functions.  <B>DASMx</B> does not currently support these additional instructions.</P>
<P ALIGN="JUSTIFY">Like the 6502, the Z80 has spawned many variants with opcode compatible instruction supersets.  <B>DASMx</B> can be used on code for these devices with the standard caveat that any of the new instructions will not be disassembled as valid code (and therefore code threading is not advised.)</P>
</FONT><B><FONT FACE="AvantGarde,Century Gothic" SIZE=4><P>Sharp LR35902 (GameBoy processor)</P>
</B></FONT><FONT FACE="Palatino,Book Antiqua"><P ALIGN="JUSTIFY">The Sharp LR35902 is the processor used in the hugely popular Nintendo GameBoy.  This processor is a single chip variant of the Zilog Z80.  The instruction set is based on a subset of that of the Z80 but with some additional instructions.  Of those instructions that are shared with the Z80, most are opcode compatible but there are a few differences.</P>
<P ALIGN="JUSTIFY">As a single chip microcontroller, the LR35902 contains various on-chip I/O and timer functions.  These are accessed through a 256 byte memory page starting at address 0xFF00.  The supplied file, <B>gameboy.sym</B>, contains a set of known symbol definitions for these memory mapped registers.  This generic GameBoy processor symbol file may be included in the main symbol file for the disassembly of a specific binary image.  The supplied <B>tetris.sym</B> file shows an example of this.</P>
<P ALIGN="JUSTIFY"></P></FONT>
<P ALIGN="CENTER"><CENTER><TABLE BORDER CELLSPACING=2 CELLPADDING=7 WIDTH=510>
<TR><TD VALIGN="TOP">
<B><FONT FACE="Palatino,Book Antiqua"><P ALIGN="JUSTIFY">WARNING</B>: unlike all the other processors supported by <B>DASMx</B>, it has not been possible to obtain <I>official</I> manufacturer's data on the Sharp LR35902.  The information used is derived from a number of different public domain documents – some of which conflict over certain details.  Consequently, the LR35902 disassembly should be considered provisional and potentially subject to error.</P>
<P ALIGN="JUSTIFY">If anyone has access to genuine Sharp (or other official) data on this device please contact the author: <A HREF="mailto:pclare@bigfoot.com">pclare@bigfoot.com</A>.</FONT></TD>
</TR>
</TABLE>
</CENTER></P>

<FONT FACE="Palatino,Book Antiqua"><P ALIGN="JUSTIFY">&nbsp;</P>
</FONT><B><FONT FACE="AvantGarde,Century Gothic" SIZE=4><P>Intel MCS-80/85&trade; (8080 and 8085)</P>
</B></FONT><FONT FACE="Palatino,Book Antiqua"><P ALIGN="JUSTIFY">The Intel 8080 and 8085 share an almost identical instruction set.  The Intel 8085 is an enhanced version of the 8080, with two additional instructions (</FONT><FONT FACE="Courier">rim</FONT><FONT FACE="Palatino,Book Antiqua"> and </FONT><FONT FACE="Courier">sim</FONT><FONT FACE="Palatino,Book Antiqua">) used to control new serial in and out pins and interrupt inputs.</P>
<P ALIGN="JUSTIFY">When disassembling 8080 (and, with provisos, 8085) code the user has the option of generating either Intel or Zilog mnemonics.  To generate Intel mnemonics, simply specify the CPU type to be </FONT><FONT FACE="Courier">8080</FONT><FONT FACE="Palatino,Book Antiqua"> or </FONT><FONT FACE="Courier">8085</FONT><FONT FACE="Palatino,Book Antiqua"> as required.</P>
<P ALIGN="JUSTIFY">Generating Zilog Z80 style mnemonics from Intel 8080 code is possible because the 8080 has an instruction set that is a compatible binary subset of those of the Z80.  Simply specify the CPU type is as </FONT><FONT FACE="Courier">Z80</FONT><FONT FACE="Palatino,Book Antiqua"> and <B>DASMx</B> will correctly disassemble 8080 code into Zilog mnemonics.  This will not suit Intel assembler die-hards, but may be preferred by those more familiar with the Z80.</P>
<P ALIGN="JUSTIFY">WARNING: if <B>DASMx</B> is used as a Z80 disassembler on 8085 code and either of the two 8085 specific instructions are used  (</FONT><FONT FACE="Courier">rim</FONT><FONT FACE="Palatino,Book Antiqua"> and </FONT><FONT FACE="Courier">sim</FONT><FONT FACE="Palatino,Book Antiqua">) then problems will result.  In such cases Zilog disassembly is probably best avoided.  If you really must have Zilog mnemonics then read the following description of how these instructions are handled and be prepared for code threading to work incorrectly.</P>
</FONT><FONT FACE="Courier"><P ALIGN="JUSTIFY">rim</FONT><FONT FACE="Palatino,Book Antiqua"> is a one byte instruction, but <B>DASMx</B> will attempt to disassemble this as the two byte </FONT><FONT FACE="Courier">jr&nbsp;nz</FONT><FONT FACE="Palatino,Book Antiqua"> Z80 instruction.  This will both generate a false label and ignore the next byte in the 8085 opcode stream.  Since that could be the first byte in a multi-byte opcode it could take a number of erroneously disassembled instructions before synchronisation is achieved.</P>
</FONT><FONT FACE="Courier"><P ALIGN="JUSTIFY">sim</FONT><FONT FACE="Palatino,Book Antiqua"> is a one byte instruction that will be disassembled as the first byte of the three byte </FONT><FONT FACE="Courier">ld&nbsp;hl</FONT><FONT FACE="Palatino,Book Antiqua"> immediate instruction.  The results will be similar to those for </FONT><FONT FACE="Courier">rim</FONT><FONT FACE="Palatino,Book Antiqua">.</P>
</FONT><B><FONT FACE="AvantGarde,Century Gothic" SIZE=4><P>Intel MCS-48&trade; family (8048 etc.)</P>
</FONT><FONT FACE="Palatino,Book Antiqua"><P ALIGN="JUSTIFY">DASMx</B> will disassemble opcodes for the following Intel MCS-48&trade; family devices (and equivalents from second source manufacturers): 8021, 8022, 8035, 8039, 8041, 8741, 8048, 8049 and 8748.  The CPU type should be set to </FONT><FONT FACE="Courier">8048</FONT><FONT FACE="Palatino,Book Antiqua"> and the term "8048" is used throughout this documentation to refer to this family of devices.</P>
<P ALIGN="JUSTIFY">The 8021 instruction set is a much reduced subset of the full 8048 set of instructions.</P>
<P ALIGN="JUSTIFY">The 8022 has a very similar instruction set to the 8021, but with slightly more of the 8048 instructions and a few new instructions to handle the on-chip analogue to digital converter.</P>
<P ALIGN="JUSTIFY">The 8041/8741 has almost the same instruction set as the 8048, but with just a few instructions missing.</P>
<B><P ALIGN="JUSTIFY">DASMx</B> can disassemble code for the 8021, 8022, 8041 and 8741 variants with the caveat that data areas may be disassembled as 8048 instructions that are in fact illegal on the variant.</P>
<P ALIGN="JUSTIFY">The 8048 jump and call instructions operate on an 11-bit address (i.e. within a 2&nbsp;Kbyte memory bank).  A memory bank select bit (controlled by the </FONT><FONT FACE="Courier">sel&nbsp;mb0</FONT><FONT FACE="Palatino,Book Antiqua"> and </FONT><FONT FACE="Courier">sel&nbsp;mb1</FONT><FONT FACE="Palatino,Book Antiqua"> instructions) is combined with the 11-bit jump/call address to give full 12-bit addressing within the 4&nbsp;Kbyte address space of the 8048.  This presents a problem for the code threading and automatic label generation functions of <B>DASMx</B> since a destination address can only be fully calculated if the last memory bank select operation is known.  Tracking the state of the memory bank select bit is currently beyond the capabilities of <B>DASMx</B>.  For this reason, it is advised that code threading be not used if the size of the 8048 source image exceeds 2&nbsp;Kbytes.  If images greater than this are disassembled, even with threading disabled, some errors in automatically generated labels may be expected.</P>
</FONT><B><FONT FACE="AvantGarde,Century Gothic" SIZE=4><P>Intel MCS-51&trade; family (8051 etc.)</P>
</B></FONT><FONT FACE="Palatino,Book Antiqua"><P ALIGN="JUSTIFY">Intel introduced the 8051 to provide an upgrade path from the 8048.  It would do all that the 8048 would do and more.  The heritage of the 8048 is obvious in the architecture and instruction set of the 8051.</P>
<P ALIGN="JUSTIFY">Like the 8048, the 8051 was initially available in a number of variants (e.g. 8031 and 8751).  Subsequently, many further variants of the 8051 have been produced by Intel and by other manufacturers.  Some of these added to the instruction set.</P>
<B><P ALIGN="JUSTIFY">DASMx</B> will only correctly disassemble code for the original 8051 devices that shared the MCS-51&trade; instruction set.</P>
</FONT><B><FONT FACE="AvantGarde,Century Gothic" SIZE=4><P>Signetics 2650</P>
</B></FONT><FONT FACE="Palatino,Book Antiqua"><P ALIGN="JUSTIFY">The Signetics 2650 is a rather oddball processor when compared to most other processors handled by <B>DASMx</B>.  It operates on 8-bit data and can address 32,768 bytes of memory organised in four pages of 8,192 bytes each.  It has a large range of addressing modes, made possible by the use of bits encoded in the second byte of two and three byte instructions.  It has a 3-bit stack pointer which means that subroutines can be nested to, at most, eight deep.</P>
</FONT><B><FONT FACE="AvantGarde,Century Gothic" SIZE=5><P>Assembler pseudo operations</P>
</B></FONT><FONT FACE="Palatino,Book Antiqua"><P ALIGN="JUSTIFY">Assembler pseudo operations (e.g. that to define a data word) are <I>not</I> in a standard style that matches the chosen processor.  The pseudo-ops are common across all processor disassembly output.  In general, the pseudo-ops follow Intel conventions:</P>

<UL TYPE="CIRCLE">
<LI>the ';' character to denote a comment;</LI>
<LI>the ':' character following a label;</LI>
<B><LI>db</B>, to define a data byte, character or string;</LI>
<B><LI>dw</B>, to define a data word;</LI>
<B><LI>org</B>, to specify a starting address.</LI></UL>

<P ALIGN="JUSTIFY">If these do not suit your preferred assembler, then use of search and replace in a text editor can probably effect the required changes.</P>
</FONT><B><FONT FACE="AvantGarde,Century Gothic" SIZE=5><P>Number format</P>
</B></FONT><FONT FACE="Palatino,Book Antiqua"><P ALIGN="JUSTIFY">Microprocessor manufacturers have chosen a variety of different formats for representing hexadecimal numbers.  [Some sort of formatting is essential, otherwise a hex number starting with an alpha character could be confused with a label or symbol name.]</P>
<B><P ALIGN="JUSTIFY">DASMx</B> supports five different hex number format styles.  These are summarised in the table below, with an example in each case for the hex number F12C.</P>
<P ALIGN="JUSTIFY"></P></FONT>
<P ALIGN="CENTER"><CENTER><TABLE BORDER CELLSPACING=2 BORDERCOLOR="#000000" CELLPADDING=7 WIDTH=406>
<TR><TD WIDTH="33%" VALIGN="TOP">
<B><I><FONT FACE="Palatino,Book Antiqua"><P ALIGN="JUSTIFY">Number format</B></I></FONT></TD>
<TD WIDTH="44%" VALIGN="TOP">
<B><I><FONT FACE="Courier"><P ALIGN="JUSTIFY">numformat</FONT><FONT FACE="Palatino,Book Antiqua"> parameter</B></I></FONT></TD>
<TD WIDTH="23%" VALIGN="TOP">
<B><I><FONT FACE="Palatino,Book Antiqua"><P ALIGN="JUSTIFY">Example</B></I></FONT></TD>
</TR>
<TR><TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Palatino,Book Antiqua"><P ALIGN="JUSTIFY">Intel</FONT></TD>
<TD WIDTH="44%" VALIGN="TOP">
<FONT FACE="Courier"><P ALIGN="JUSTIFY">I</FONT></TD>
<TD WIDTH="23%" VALIGN="TOP">
<FONT FACE="Courier"><P ALIGN="JUSTIFY">0F12CH</FONT></TD>
</TR>
<TR><TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Palatino,Book Antiqua"><P ALIGN="JUSTIFY">Motorola</FONT></TD>
<TD WIDTH="44%" VALIGN="TOP">
<FONT FACE="Courier"><P ALIGN="JUSTIFY">M</FONT></TD>
<TD WIDTH="23%" VALIGN="TOP">
<FONT FACE="Courier"><P ALIGN="JUSTIFY">$F12C</FONT></TD>
</TR>
<TR><TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Palatino,Book Antiqua"><P ALIGN="JUSTIFY">Signetics</FONT></TD>
<TD WIDTH="44%" VALIGN="TOP">
<FONT FACE="Courier"><P ALIGN="JUSTIFY">S</FONT></TD>
<TD WIDTH="23%" VALIGN="TOP">
<FONT FACE="Courier"><P ALIGN="JUSTIFY">H'F12C'</FONT></TD>
</TR>
<TR><TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Palatino,Book Antiqua"><P ALIGN="JUSTIFY">C language</FONT></TD>
<TD WIDTH="44%" VALIGN="TOP">
<FONT FACE="Courier"><P ALIGN="JUSTIFY">C</FONT></TD>
<TD WIDTH="23%" VALIGN="TOP">
<FONT FACE="Courier"><P ALIGN="JUSTIFY">0xF12C</FONT></TD>
</TR>
<TR><TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Palatino,Book Antiqua"><P ALIGN="JUSTIFY">Decimal</FONT></TD>
<TD WIDTH="44%" VALIGN="TOP">
<FONT FACE="Courier"><P ALIGN="JUSTIFY">D</FONT></TD>
<TD WIDTH="23%" VALIGN="TOP">
<FONT FACE="Courier"><P ALIGN="JUSTIFY">61740</FONT></TD>
</TR>
</TABLE>
</CENTER></P>

<FONT FACE="Palatino,Book Antiqua"><P ALIGN="JUSTIFY">&nbsp;</P>
<B><P ALIGN="JUSTIFY">DASMx</B> chooses a default number format according to the CPU type setting.  The default choice can be overriden by a </FONT><FONT FACE="Courier">numformat</FONT><FONT FACE="Palatino,Book Antiqua"> statement in the symbol file.  The number format defaults for the processors supported by <B>DASMx</B> are given in the following table.</P>
<P ALIGN="JUSTIFY"></P></FONT>
<P ALIGN="CENTER"><CENTER><TABLE BORDER CELLSPACING=2 BORDERCOLOR="#000000" CELLPADDING=7 WIDTH=406>
<TR><TD WIDTH="40%" VALIGN="TOP">
<B><I><FONT FACE="Palatino,Book Antiqua"><P ALIGN="JUSTIFY">Manufacturer</B></I></FONT></TD>
<TD WIDTH="30%" VALIGN="TOP">
<B><I><FONT FACE="Courier"><P ALIGN="JUSTIFY">cpu</FONT><FONT FACE="Palatino,Book Antiqua"> parameter</B></I></FONT></TD>
<TD WIDTH="30%" VALIGN="TOP">
<B><I><FONT FACE="Palatino,Book Antiqua"><P ALIGN="JUSTIFY">Format</B></I></FONT></TD>
</TR>
<TR><TD WIDTH="40%" VALIGN="TOP">
<FONT FACE="Palatino,Book Antiqua"><P ALIGN="JUSTIFY">Signetics</FONT></TD>
<TD WIDTH="30%" VALIGN="TOP">
<FONT FACE="Courier"><P ALIGN="JUSTIFY">2650</FONT></TD>
<TD WIDTH="30%" VALIGN="TOP">
<FONT FACE="Palatino,Book Antiqua"><P ALIGN="JUSTIFY">Signetics</FONT></TD>
</TR>
<TR><TD WIDTH="40%" VALIGN="TOP">
<FONT FACE="Palatino,Book Antiqua"><P ALIGN="JUSTIFY">MOS Technology</FONT></TD>
<TD WIDTH="30%" VALIGN="TOP">
<FONT FACE="Courier"><P ALIGN="JUSTIFY">6502</FONT></TD>
<TD WIDTH="30%" VALIGN="TOP">
<FONT FACE="Palatino,Book Antiqua"><P ALIGN="JUSTIFY">Motorola</FONT></TD>
</TR>
<TR><TD WIDTH="40%" VALIGN="TOP">
<FONT FACE="Palatino,Book Antiqua"><P ALIGN="JUSTIFY">Rockwell</FONT></TD>
<TD WIDTH="30%" VALIGN="TOP">
<FONT FACE="Courier"><P ALIGN="JUSTIFY">65C00</FONT></TD>
<TD WIDTH="30%" VALIGN="TOP">
<FONT FACE="Palatino,Book Antiqua"><P ALIGN="JUSTIFY">Motorola</FONT></TD>
</TR>
<TR><TD WIDTH="40%" VALIGN="TOP">
<FONT FACE="Palatino,Book Antiqua"><P ALIGN="JUSTIFY">Rockwell</FONT></TD>
<TD WIDTH="30%" VALIGN="TOP">
<FONT FACE="Courier"><P ALIGN="JUSTIFY">65C02</FONT></TD>
<TD WIDTH="30%" VALIGN="TOP">
<FONT FACE="Palatino,Book Antiqua"><P ALIGN="JUSTIFY">Motorola</FONT></TD>
</TR>
<TR><TD WIDTH="40%" VALIGN="TOP">
<FONT FACE="Palatino,Book Antiqua"><P ALIGN="JUSTIFY">Rockwell</FONT></TD>
<TD WIDTH="30%" VALIGN="TOP">
<FONT FACE="Courier"><P ALIGN="JUSTIFY">65C29</FONT></TD>
<TD WIDTH="30%" VALIGN="TOP">
<FONT FACE="Palatino,Book Antiqua"><P ALIGN="JUSTIFY">Motorola</FONT></TD>
</TR>
<TR><TD WIDTH="40%" VALIGN="TOP">
<FONT FACE="Palatino,Book Antiqua"><P ALIGN="JUSTIFY">Rockwell</FONT></TD>
<TD WIDTH="30%" VALIGN="TOP">
<FONT FACE="Courier"><P ALIGN="JUSTIFY">65C102</FONT></TD>
<TD WIDTH="30%" VALIGN="TOP">
<FONT FACE="Palatino,Book Antiqua"><P ALIGN="JUSTIFY">Motorola</FONT></TD>
</TR>
<TR><TD WIDTH="40%" VALIGN="TOP">
<FONT FACE="Palatino,Book Antiqua"><P ALIGN="JUSTIFY">Rockwell</FONT></TD>
<TD WIDTH="30%" VALIGN="TOP">
<FONT FACE="Courier"><P ALIGN="JUSTIFY">65C112</FONT></TD>
<TD WIDTH="30%" VALIGN="TOP">
<FONT FACE="Palatino,Book Antiqua"><P ALIGN="JUSTIFY">Motorola</FONT></TD>
</TR>
<TR><TD WIDTH="40%" VALIGN="TOP">
<FONT FACE="Palatino,Book Antiqua"><P ALIGN="JUSTIFY">Hitachi</FONT></TD>
<TD WIDTH="30%" VALIGN="TOP">
<FONT FACE="Courier"><P ALIGN="JUSTIFY">6301</FONT></TD>
<TD WIDTH="30%" VALIGN="TOP">
<FONT FACE="Palatino,Book Antiqua"><P ALIGN="JUSTIFY">Motorola</FONT></TD>
</TR>
<TR><TD WIDTH="40%" VALIGN="TOP">
<FONT FACE="Palatino,Book Antiqua"><P ALIGN="JUSTIFY">Hitachi</FONT></TD>
<TD WIDTH="30%" VALIGN="TOP">
<FONT FACE="Courier"><P ALIGN="JUSTIFY">6303</FONT></TD>
<TD WIDTH="30%" VALIGN="TOP">
<FONT FACE="Palatino,Book Antiqua"><P ALIGN="JUSTIFY">Motorola</FONT></TD>
</TR>
<TR><TD WIDTH="40%" VALIGN="TOP">
<FONT FACE="Palatino,Book Antiqua"><P ALIGN="JUSTIFY">Motorola</FONT></TD>
<TD WIDTH="30%" VALIGN="TOP">
<FONT FACE="Courier"><P ALIGN="JUSTIFY">6800</FONT></TD>
<TD WIDTH="30%" VALIGN="TOP">
<FONT FACE="Palatino,Book Antiqua"><P ALIGN="JUSTIFY">Motorola</FONT></TD>
</TR>
<TR><TD WIDTH="40%" VALIGN="TOP">
<FONT FACE="Palatino,Book Antiqua"><P ALIGN="JUSTIFY">Motorola</FONT></TD>
<TD WIDTH="30%" VALIGN="TOP">
<FONT FACE="Courier"><P ALIGN="JUSTIFY">6801</FONT></TD>
<TD WIDTH="30%" VALIGN="TOP">
<FONT FACE="Palatino,Book Antiqua"><P ALIGN="JUSTIFY">Motorola</FONT></TD>
</TR>
<TR><TD WIDTH="40%" VALIGN="TOP">
<FONT FACE="Palatino,Book Antiqua"><P ALIGN="JUSTIFY">Motorola</FONT></TD>
<TD WIDTH="30%" VALIGN="TOP">
<FONT FACE="Courier"><P ALIGN="JUSTIFY">6802</FONT></TD>
<TD WIDTH="30%" VALIGN="TOP">
<FONT FACE="Palatino,Book Antiqua"><P ALIGN="JUSTIFY">Motorola</FONT></TD>
</TR>
<TR><TD WIDTH="40%" VALIGN="TOP">
<FONT FACE="Palatino,Book Antiqua"><P ALIGN="JUSTIFY">Motorola</FONT></TD>
<TD WIDTH="30%" VALIGN="TOP">
<FONT FACE="Courier"><P ALIGN="JUSTIFY">6803</FONT></TD>
<TD WIDTH="30%" VALIGN="TOP">
<FONT FACE="Palatino,Book Antiqua"><P ALIGN="JUSTIFY">Motorola</FONT></TD>
</TR>
<TR><TD WIDTH="40%" VALIGN="TOP">
<FONT FACE="Palatino,Book Antiqua"><P ALIGN="JUSTIFY">Motorola</FONT></TD>
<TD WIDTH="30%" VALIGN="TOP">
<FONT FACE="Courier"><P ALIGN="JUSTIFY">6808</FONT></TD>
<TD WIDTH="30%" VALIGN="TOP">
<FONT FACE="Palatino,Book Antiqua"><P ALIGN="JUSTIFY">Motorola</FONT></TD>
</TR>
<TR><TD WIDTH="40%" VALIGN="TOP">
<FONT FACE="Palatino,Book Antiqua"><P ALIGN="JUSTIFY">Motorola</FONT></TD>
<TD WIDTH="30%" VALIGN="TOP">
<FONT FACE="Courier"><P ALIGN="JUSTIFY">6809</FONT></TD>
<TD WIDTH="30%" VALIGN="TOP">
<FONT FACE="Palatino,Book Antiqua"><P ALIGN="JUSTIFY">Motorola</FONT></TD>
</TR>
<TR><TD WIDTH="40%" VALIGN="TOP">
<FONT FACE="Palatino,Book Antiqua"><P ALIGN="JUSTIFY">Intel</FONT></TD>
<TD WIDTH="30%" VALIGN="TOP">
<FONT FACE="Courier"><P ALIGN="JUSTIFY">8048</FONT></TD>
<TD WIDTH="30%" VALIGN="TOP">
<FONT FACE="Palatino,Book Antiqua"><P ALIGN="JUSTIFY">Intel</FONT></TD>
</TR>
<TR><TD WIDTH="40%" VALIGN="TOP">
<FONT FACE="Palatino,Book Antiqua"><P ALIGN="JUSTIFY">Intel</FONT></TD>
<TD WIDTH="30%" VALIGN="TOP">
<FONT FACE="Courier"><P ALIGN="JUSTIFY">8051</FONT></TD>
<TD WIDTH="30%" VALIGN="TOP">
<FONT FACE="Palatino,Book Antiqua"><P ALIGN="JUSTIFY">Intel</FONT></TD>
</TR>
<TR><TD WIDTH="40%" VALIGN="TOP">
<FONT FACE="Palatino,Book Antiqua"><P ALIGN="JUSTIFY">Intel</FONT></TD>
<TD WIDTH="30%" VALIGN="TOP">
<FONT FACE="Courier"><P ALIGN="JUSTIFY">8080</FONT></TD>
<TD WIDTH="30%" VALIGN="TOP">
<FONT FACE="Palatino,Book Antiqua"><P ALIGN="JUSTIFY">Intel</FONT></TD>
</TR>
<TR><TD WIDTH="40%" VALIGN="TOP">
<FONT FACE="Palatino,Book Antiqua"><P ALIGN="JUSTIFY">Intel</FONT></TD>
<TD WIDTH="30%" VALIGN="TOP">
<FONT FACE="Courier"><P ALIGN="JUSTIFY">8085</FONT></TD>
<TD WIDTH="30%" VALIGN="TOP">
<FONT FACE="Palatino,Book Antiqua"><P ALIGN="JUSTIFY">Intel</FONT></TD>
</TR>
<TR><TD WIDTH="40%" VALIGN="TOP">
<FONT FACE="Palatino,Book Antiqua"><P ALIGN="JUSTIFY">Zilog</FONT></TD>
<TD WIDTH="30%" VALIGN="TOP">
<FONT FACE="Courier"><P ALIGN="JUSTIFY">Z80</FONT></TD>
<TD WIDTH="30%" VALIGN="TOP">
<FONT FACE="Palatino,Book Antiqua"><P ALIGN="JUSTIFY">Intel</FONT></TD>
</TR>
<TR><TD WIDTH="40%" VALIGN="TOP">
<FONT FACE="Palatino,Book Antiqua"><P ALIGN="JUSTIFY">Sharp</FONT></TD>
<TD WIDTH="30%" VALIGN="TOP">
<FONT FACE="Courier"><P ALIGN="JUSTIFY">LR35902</FONT></TD>
<TD WIDTH="30%" VALIGN="TOP">
<FONT FACE="Palatino,Book Antiqua"><P ALIGN="JUSTIFY">Intel</FONT></TD>
</TR>
</TABLE>
</CENTER></P>

<FONT FACE="Palatino,Book Antiqua"><P ALIGN="JUSTIFY">&nbsp;</P>
<P ALIGN="JUSTIFY">The number formatting applies to all operands in disassembled instructions with the exception of small positive or negative offsets in 6809 index instructions.  These are given as a signed decimal number.</P>
</FONT><B><FONT FACE="AvantGarde,Century Gothic" SIZE=6><P>Future enhancements</P>
</B></FONT><FONT FACE="Palatino,Book Antiqua"><P ALIGN="JUSTIFY">Whilst there is no guarantee that future versions of this disassembler software will be released, some or all of the following areas are likely to receive attention in any future version:</P>

<UL TYPE="CIRCLE">
<LI>fixing any errors discovered in the instruction mnemonics or disassembly of an opcode to its instruction;</LI>
<LI>rationalisation of the pseudo-ops such that the assembler output can be fed directly into at least one common assembler without further text editing;</LI>
<LI>improved code threading (through use of a more complete emulation of the processor);</LI>
<LI>improved symbol table output in listing file;</LI>
<LI>specifying comments in the symbol file for inclusion in the output files;</LI>
<LI>additional memory map output in listing file;</LI>
<LI>better support for 8048 code greater than 2&nbsp;Kbytes and for 8048 variants;</LI>
<LI>support for additional microprocessors;</LI>
<LI>support for further variants of the currently supported processors;</LI>
<LI>disassembly of commonly known "undocumented" instructions.</LI></UL>

<P ALIGN="JUSTIFY">Fixing actual disassembly errors (if any are discovered) will be treated with priority.</P>
<P ALIGN="JUSTIFY">Note that it is not currently intended to support platforms other than Windows 95/98/Millenium or Windows NT/2000.  In particular, there will be no 16-bit versions for DOS or any other 16-bit operating systems.  If the demand exists, a Linux version may be produced.</P>
</FONT><B><FONT FACE="AvantGarde,Century Gothic" SIZE=6><P>Contacting the author</P>
</B></FONT><FONT FACE="Palatino,Book Antiqua"><P ALIGN="JUSTIFY">Feedback to Conquest Consultants may be made via <A HREF="mailto:pclare@bigfoot.com">pclare@bigfoot.com</A>.</P>
</FONT><B><FONT FACE="AvantGarde,Century Gothic" SIZE=6><P>References</P>
</B></FONT><FONT FACE="Palatino,Book Antiqua"><P ALIGN="JUSTIFY">The following publications were referred to in the course of the development of <B>DASMx</B>.  This may also be considered to be a useful reference list for anyone programming these processors at assembler level and/or inspecting the output of <B>DASMx</B>.</P></FONT>
<TABLE CELLSPACING=0 BORDER=0 CELLPADDING=7 WIDTH=602>
<TR><TD WIDTH="9%" VALIGN="TOP">
<FONT FACE="Palatino,Book Antiqua"><P ALIGN="CENTER">[1]</FONT></TD>
<TD WIDTH="91%" VALIGN="TOP">
<I><FONT FACE="Palatino,Book Antiqua"><P>M6800 Microprocessor Applications Manual</I>, Motorola Semiconductor Products Inc., First Edition, 1975.</FONT></TD>
</TR>
<TR><TD WIDTH="9%" VALIGN="TOP">
<FONT FACE="Palatino,Book Antiqua"><P ALIGN="CENTER">[2]</FONT></TD>
<TD WIDTH="91%" VALIGN="TOP">
<I><FONT FACE="Palatino,Book Antiqua"><P>Hitachi Microcomputer Databook 8-bit HD6800 &amp; 16-bit HD68000</I>, Hitachi Ltd., March 1983.</FONT></TD>
</TR>
<TR><TD WIDTH="9%" VALIGN="TOP">
<FONT FACE="Palatino,Book Antiqua"><P ALIGN="CENTER">[3]</FONT></TD>
<TD WIDTH="91%" VALIGN="TOP">
<I><FONT FACE="Palatino,Book Antiqua"><P>Programming the 6502</I>, Rodnay Zaks, Sybex, ISBN&nbsp;0-89588-046-6, Third Edition, 1980.</FONT></TD>
</TR>
<TR><TD WIDTH="9%" VALIGN="TOP">
<FONT FACE="Palatino,Book Antiqua"><P ALIGN="CENTER">[4]</FONT></TD>
<TD WIDTH="91%" VALIGN="TOP">
<I><FONT FACE="Palatino,Book Antiqua"><P>6502 Assembly Language Programming</I>, Lance A.Leventhal, Osborne/McGraw-Hill, ISBN&nbsp;0-931988-27-6, 1979.</FONT></TD>
</TR>
<TR><TD WIDTH="9%" VALIGN="TOP">
<FONT FACE="Palatino,Book Antiqua"><P ALIGN="CENTER">[5]</FONT></TD>
<TD WIDTH="91%" VALIGN="TOP">
<I><FONT FACE="Palatino,Book Antiqua"><P>6502 Assembly Language Programming</I>, Second Edition, Lance A.Leventhal, Osborne/McGraw-Hill, ISBN&nbsp;0-07-881216-X, 1986.</FONT></TD>
</TR>
<TR><TD WIDTH="9%" VALIGN="TOP">
<FONT FACE="Palatino,Book Antiqua"><P ALIGN="CENTER">[6]</FONT></TD>
<TD WIDTH="91%" VALIGN="TOP">
<I><FONT FACE="Palatino,Book Antiqua"><P>R650X and R651X Microprocessors (CPU)</I>, Rockwell, 29000D39, Data Sheet D39, Revision 6, February 1984.</FONT></TD>
</TR>
<TR><TD WIDTH="9%" VALIGN="TOP">
<FONT FACE="Palatino,Book Antiqua"><P ALIGN="CENTER">[7]</FONT></TD>
<TD WIDTH="91%" VALIGN="TOP">
<I><FONT FACE="Palatino,Book Antiqua"><P>MCS6500 Microcomputer Family Programming Manual</I>, MOS Technology Inc., Second Edition, Publication Number 6500-50A, January 1976.</FONT></TD>
</TR>
<TR><TD WIDTH="9%" VALIGN="TOP">
<FONT FACE="Palatino,Book Antiqua"><P ALIGN="CENTER">[8]</FONT></TD>
<TD WIDTH="91%" VALIGN="TOP">
<I><FONT FACE="Palatino,Book Antiqua"><P>1984 Data Book</I>, Semiconductor Products Division, Rockwell International, March 1984.</FONT></TD>
</TR>
<TR><TD WIDTH="9%" VALIGN="TOP">
<FONT FACE="Palatino,Book Antiqua"><P ALIGN="CENTER">[9]</FONT></TD>
<TD WIDTH="91%" VALIGN="TOP">
<I><FONT FACE="Palatino,Book Antiqua"><P>TLCS-Z80 System Manual</I>, Toshiba, 4419 '84-05(CK), June 1984.</FONT></TD>
</TR>
<TR><TD WIDTH="9%" VALIGN="TOP">
<FONT FACE="Palatino,Book Antiqua"><P ALIGN="CENTER">[10]</FONT></TD>
<TD WIDTH="91%" VALIGN="TOP">
<I><FONT FACE="Palatino,Book Antiqua"><P>Microcomputer Components Databook</I>, Mostek, MK79778, July 1979.</FONT></TD>
</TR>
<TR><TD WIDTH="9%" VALIGN="TOP">
<FONT FACE="Palatino,Book Antiqua"><P ALIGN="CENTER">[11]</FONT></TD>
<TD WIDTH="91%" VALIGN="TOP">
<I><FONT FACE="Palatino,Book Antiqua"><P>Z80-Assembly Language Programming Manual</I>, Zilog, 03-0002-01, Rev B, April 1980.</FONT></TD>
</TR>
<TR><TD WIDTH="9%" VALIGN="TOP">
<FONT FACE="Palatino,Book Antiqua"><P ALIGN="CENTER">[12]</FONT></TD>
<TD WIDTH="91%" VALIGN="TOP">
<I><FONT FACE="Palatino,Book Antiqua"><P>The MCS-80/85 Family User's Manual</I>, Intel, ISBN&nbsp;1-55512-009-1, 1986.</FONT></TD>
</TR>
<TR><TD WIDTH="9%" VALIGN="TOP">
<FONT FACE="Palatino,Book Antiqua"><P ALIGN="CENTER">[13]</FONT></TD>
<TD WIDTH="91%" VALIGN="TOP">
<I><FONT FACE="Palatino,Book Antiqua"><P>MCS-48<SUP>TM</SUP> User's Manual</I>, Intel, 9800270D, July 1978.</FONT></TD>
</TR>
<TR><TD WIDTH="9%" VALIGN="TOP">
<FONT FACE="Palatino,Book Antiqua"><P ALIGN="CENTER">[14]</FONT></TD>
<TD WIDTH="91%" VALIGN="TOP">
<I><FONT FACE="Palatino,Book Antiqua"><P>48-Series Microprocessors Handbook</I>, National Semiconductor, 1980.</FONT></TD>
</TR>
<TR><TD WIDTH="9%" VALIGN="TOP">
<FONT FACE="Palatino,Book Antiqua"><P ALIGN="CENTER">[15]</FONT></TD>
<TD WIDTH="91%" VALIGN="TOP">
<I><FONT FACE="Palatino,Book Antiqua"><P>Component Data Catalog</I>, Intel, 1980.</FONT></TD>
</TR>
<TR><TD WIDTH="9%" VALIGN="TOP">
<FONT FACE="Palatino,Book Antiqua"><P ALIGN="CENTER">[16]</FONT></TD>
<TD WIDTH="91%" VALIGN="TOP">
<I><FONT FACE="Palatino,Book Antiqua"><P>An Introduction to Microcomputers: Volume 1, Basic Concepts</I>, Second Edition, Adam Osborne, Osborne/McGraw-Hill, ISBN&nbsp;0-931988-34-9, 1980.</FONT></TD>
</TR>
<TR><TD WIDTH="9%" VALIGN="TOP">
<FONT FACE="Palatino,Book Antiqua"><P ALIGN="CENTER">[17]</FONT></TD>
<TD WIDTH="91%" VALIGN="TOP">
<I><FONT FACE="Palatino,Book Antiqua"><P>Osborne 4 &amp; 8-Bit Microprocessor Handbook</I>, Adam Osborne &amp; Gerry Kane, Osborne/McGraw-Hill, ISBN&nbsp;0-931988-42-X, 1980.</FONT></TD>
</TR>
<TR><TD WIDTH="9%" VALIGN="TOP">
<FONT FACE="Palatino,Book Antiqua"><P ALIGN="CENTER">[18]</FONT></TD>
<TD WIDTH="91%" VALIGN="TOP">
<I><FONT FACE="Palatino,Book Antiqua"><P>2650A/2650A-1 Data Sheet</I>, Signetics.</FONT></TD>
</TR>
</TABLE>

<FONT FACE="Palatino,Book Antiqua"><P ALIGN="JUSTIFY"></P></FONT></BODY>
</HTML>
